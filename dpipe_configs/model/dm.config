from dpipe_configs.model.torch_model import *
from dpipe.predict import predict_patches_dividable

from functools import partial

import numpy as np
import torch.nn as nn

import dpipe.layers as lrs

predict = partial(predict_patches_dividable, predict=model.do_inf_step,
                  patch_size=np.array(predict_patch_size), stride=np.array(predict_stride), divisor=3)

# MODEL
init_structure = [n_chans_in, 30, 30]
structure = [30, 40, 40, 50]

activation = partial(nn.functional.relu, inplace=True)

rb = partial(lrs.ResBlock3d, kernel_size=3, activation=activation)

path1 = nn.Sequential(
    lrs.CenteredCrop([16, 16, 16]),
    lrs.make_res_init_path_3d(init_structure, kernel_size=3, padding=0, activation=activation),
    *lrs.make_pipeline(structure, make_transformer=rb),
)

path2 = nn.Sequential(
    nn.AvgPool3d(kernel_size=3),
    lrs.make_res_init_path_3d(init_structure, kernel_size=3, padding=0, activation=activation),
    *lrs.make_pipeline(structure, make_transformer=rb),
    nn.Upsample(scale_factor=3)
)

model_core = nn.Sequential(
    lrs.SplitCat(path1, path2),
    rb(100, 150, kernel_size=1, activation=activation),
    lrs.PreActivation3d(150, n_chans_out, kernel_size=1, activation=activation, bias=False),
    nn.BatchNorm3d(n_chans_out),
)
