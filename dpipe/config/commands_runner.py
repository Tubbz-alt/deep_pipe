import os
import shlex
import shutil
import subprocess

from .paths import get_paths


def parse_commands(commands):
    def filter_sequence(xs):
        return filter(None, (x.strip() for x in xs))

    for line in filter_sequence(commands):
        parts = line.split('->')
        if len(parts) > 2:
            raise SyntaxError(f'Too many output separators "->" in command "{line}".')
        if len(parts) == 1:
            output = ()
        else:
            output = tuple(filter_sequence(parts[1].split()))
        yield parts[0], output


def filter_commands(parsed_commands):
    parsed_commands = list(parsed_commands)
    commands = []
    for command, output in reversed(parsed_commands):
        output = tuple(map(os.path.expanduser, output))
        if output and all(map(os.path.exists, output)):
            break
        commands.append((command, output))
    return len(parsed_commands) - len(commands), reversed(commands)


def run_commands(commands: str, config_path: str, **where):
    skip, commands = filter_commands(parse_commands(commands.format(**where).splitlines()))
    do = f'python {get_paths()["do"]} '
    if skip:
        print(f'>>> Skipping {skip} previous command(s), because the corresponding output(s) exist(s).\n', flush=True)
    for command, output in commands:
        command = do + command + ' --config_path ' + config_path
        print(f'>>> Running: {command}\n', flush=True)

        try:
            # TODO: add lock?
            # TODO: find a way to use resource_manager instead of subprocess
            subprocess.check_call(shlex.split(command))
        except subprocess.CalledProcessError as e:
            list(map(shutil.rmtree, output))
            raise RuntimeError('An exception occurred. Cleaning up...\n') from e

        if output and not all(map(os.path.exists, output)):
            raise FileNotFoundError('Not all outputs were generated by the command.')
