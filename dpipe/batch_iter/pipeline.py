from itertools import islice
from typing import Iterable, Callable, Union

import pdp


def make_infinite_batch_iter(source: Union[Iterable, pdp.Source],
                             *transformers: Union[Callable, pdp.One2One, pdp.One2Many],
                             batch_size: int, n_iters_per_epoch: int, buffer_size: int = 3):
    """
    Combine ``source`` and ``transformers`` into a batch iterator that yields batches of size ``batch_size``.

    Parameters
    ----------
    source
        an infinite iterable.
    transformers
        a callable that transforms the objects generated by the previous element of the pipeline.
    batch_size
    n_iters_per_epoch
        how many batches to yield before exhaustion.
    buffer_size
        how many objects to keep buffered in each pipeline element.
    """

    def wrap(o):
        if not isinstance(o, pdp.interface.TransformerDescription):
            o = pdp.One2One(o, buffer_size=buffer_size)
        return o

    def combine_batches(inputs):
        return tuple(zip(*inputs))

    if not isinstance(source, pdp.Source):
        source = pdp.Source(source, buffer_size=buffer_size)

    pipeline = pdp.Pipeline(source, *map(wrap, transformers), pdp.Many2One(chunk_size=batch_size, buffer_size=3),
                            pdp.One2One(combine_batches, buffer_size=buffer_size))

    class Pipeline:
        """Wrapper for `pdp.Pipeline`."""

        def close(self):
            self.__exit__(None, None, None)

        def __iter__(self):
            if not pipeline.pipeline_active:
                self.__enter__()
            return islice(pipeline, n_iters_per_epoch)

        def __enter__(self):
            pipeline.__enter__()
            return self

        def __exit__(self, exc_type, exc_val, exc_tb):
            return pipeline.__exit__(exc_type, exc_val, exc_tb)

        def __del__(self):
            self.close()

    return Pipeline()
